Мне не нравятся итераторы в стиле STL. Предлагаю другой вариант.
Основные тезисы:
    1. Итераторы привязаны к контейнерам данных;
    2. Нет необходимости отвязывать итераторы от контейнера (например, для
       передачи в качестве параметров ф-ям). Если это понадобится, то лучше
       завести для этого отдельный полиморфный тип итератора;
    3. Привязка к контейнерам данных означает, что можно обращаться с
       итератором через методы с ук-лем this на контейнер в качестве параметра.
       При этом они могут эффективно оптимизироваться (inlining);
    4. Для итераторов предлагается соглашение об именовании методов, которое
       можно дополнять и расширять.

Основная черта итераторов STL - возможность использовать их в обобщённых
алгоритмах. Того же эффекта можно добиться соглашением об именовании.

Пример:

class MyContainer
{
public:
    class MyElement
    {
    };

    class iter
    {
    };

    void iter_begin (iter * const mt_nonnull iter) const
    {
    }

    MyElement* iter_next (iter * const mt_nonnull iter) const
    {
	return NULL;
    }

    bool iter_done (iter * const mt_nonnull iter) const
    {
	return true;
    }
};

